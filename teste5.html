<!DOCTYPE html>
<html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Grid with Fixed ScrollBar</title>
        <style>
        .container {
            display: flex;
            flex-direction: column;
            width: 60vmin;
            margin: 5vmin;
            border: 0.1vmin solid #ddd;
            border-radius: 1vmin;
            overflow: hidden;
            position: relative;
        }

        /* Contêiner para rolagem horizontal */
        .grid-wrapper {
            overflow-x: auto;
            padding-right: 3vmin; /* Espaço para o ScrollBar fixo */
        }

        /* Estilo do grid */
        .grid {
            width: max-content; /* Ajusta a largura conforme as colunas */
            border-collapse: collapse;
        }

        .grid th, .grid td {
            border: 0.1vmin solid #ddd;
            padding: 1vmin;
            text-align: left;
        }

        /* Contêiner do ScrollBar fixo */
        .scroll-container {
            width: 3vmin;
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            background-color: #eee;
            display: flex;
            align-items: center;
        }

        /* Estilo do track e thumb do scrollbar */
        .scroll-track {
            position: relative;
            width: 100%;
            height: 100%; /* Ocupa 100% da altura do contêiner */
            background-color: #bbb;
            border-radius: 1.5vmin;
        }

        .scroll-thumb {
            position: absolute;
            width: 100%;
            background-color: blue;
            cursor: grab;
            border-radius: 1.5vmin;
            min-height: 3vmin;
        }

        .scroll-thumb:active {
            cursor: grabbing;
        }
    </style>
    </head>
    <body>

        <h2>Grid with Fixed ScrollBar</h2>

        <div class="container">
            <!-- Wrapper para rolagem horizontal do grid -->
            <div class="grid-wrapper" id="table-container">
                <table class="grid" id="my-grid">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Column 1</th>
                            <th>Column 2</th>
                            <th>Column 3</th>
                            <th>Column 4</th>
                            <th>Column 5</th>
                            <th>Column 6</th>
                        </tr>
                    </thead>
                    <tbody id="grid-body">
                        <!-- Dados dinâmicos -->
                    </tbody>
                </table>
            </div>

            <!-- ScrollBar fixo na direita -->
            <div id="scrollbar-container" class="scroll-container">
                <div class="scroll-track">
                    <div class="scroll-thumb"></div>
                </div>
            </div>
        </div>

        <script>
// Simulação de consulta SQL que retorna dados
function fetchDataForPage(page, rowsPerPage) {
    const data = [];
    for (let i = (page - 1) * rowsPerPage + 1; i <= page * rowsPerPage; i++) {
        data.push({ id: i, name: `Item ${i}`, col1: `Data1-${i}`, col2: `Data2-${i}`, col3: `Data3-${i}`, col4: `Data4-${i}`, col5: `Data5-${i}`, col6: `Data6-${i}` });
    }
    return data;
}

// Função para montar o grid com base nos dados
function updateGridWithData(data) {
    const gridBody = document.getElementById('grid-body');
    gridBody.innerHTML = ''; // Limpa o grid antes de atualizar

    data.forEach(row => {
        const newRow = `<tr><td>${row.id}</td><td>${row.name}</td><td>${row.col1}</td><td>${row.col2}</td><td>${row.col3}</td><td>${row.col4}</td><td>${row.col5}</td><td>${row.col6}</td></tr>`;
        gridBody.innerHTML += newRow;
    });
}

class ScrollBar {
    constructor(gridElement, totalPages, rowsPerPage) {
        let scrollbarElement = document.getElementById('scrollbar-container');
        
        this.Scrollbar = scrollbarElement.querySelector('.scroll-thumb');
        this.ScrollTrack = scrollbarElement.querySelector('.scroll-track');
        this.Grid = gridElement;
        this.IsDragging = false;
        this.CurrentPage = 1;
        this.TotalPages = totalPages;
        this.RowsPerPage = rowsPerPage;

        this.initializeEvents();
        this.loadPageData(); // Carrega a primeira página
        this.syncHeightWithContainer();
    }

    // Sincroniza a altura do ScrollBar com o container da tabela
    syncHeightWithContainer() {
        // Calcula a altura do cabeçalho e da linha em unidades de viewport
        const headerHeight = (this.Grid.querySelector('thead').offsetHeight / window.innerHeight) * 100;
        const rowHeight = (this.Grid.querySelector('tbody tr').offsetHeight / window.innerHeight) * 100;

        // Calcula a altura total do contêiner do grid em vmin
        const containerHeight = headerHeight + (rowHeight * this.RowsPerPage);

        // Define a altura do grid-wrapper e do scroll-track para cobrir a área total
        this.Grid.parentElement.style.height = `${containerHeight}vmin`;
        this.ScrollTrack.style.height = `${containerHeight}vmin`;

        // Calcula a altura do scroll-thumb de acordo com a proporção de linhas visíveis
        const thumbHeight = Math.max((this.RowsPerPage / (this.TotalPages * this.RowsPerPage)) * containerHeight, 3); // Mínimo de 3vmin
        this.Scrollbar.style.height = `${thumbHeight}vmin`;

        // Posiciona o thumb no topo do scroll-track inicialmente
        this.Scrollbar.style.top = '0vmin';
    }
    // Carrega os dados da página atual e atualiza o grid
    loadPageData() {
        const data = fetchDataForPage(this.CurrentPage, this.RowsPerPage);
        updateGridWithData(data);
    }

    // Inicializa os eventos para o scroll
    initializeEvents() {
        this.Scrollbar.onmousedown = () => {
            this.IsDragging = true;
            this.Scrollbar.body.style.userSelect = 'none';
        }

        this.Scrollbar.onmousemove = (e) => {
            if (this.IsDragging) {
                const trackRect = this.ScrollTrack.getBoundingClientRect();
                let newTop = e.clientY - trackRect.top - this.Scrollbar.offsetHeight / 2;
                this.updateScrollbarPosition(newTop);
            }
        }

        this.Scrollbar.onmouseup = () => {
            this.IsDragging = false;
            this.Scrollbar.body.style.userSelect = 'auto';
        }

        this.ScrollTrack.onclick = (e) => {
            const trackRect = this.ScrollTrack.getBoundingClientRect();
            const clickPosition = e.clientY - trackRect.top;
            this.updateScrollbarPosition(clickPosition - this.Scrollbar.offsetHeight / 2);
        }

        this.ScrollTrack.onwheel = (e) => {
            const delta = e.deltaY;
            let currentTop = parseInt(this.Scrollbar.style.top) || 0;
            let newTop = currentTop + delta * 0.2;
            this.updateScrollbarPosition(newTop);
        }
    }

    // Função para atualizar a posição do thumb e mudar de página
    updateScrollbarPosition(newTop) {
        const trackRect = this.ScrollTrack.getBoundingClientRect();

        if (newTop < 0) newTop = 0;
        if (newTop > trackRect.height - this.Scrollbar.offsetHeight) newTop = trackRect.height - this.Scrollbar.offsetHeight;

        this.Scrollbar.style.top = `${newTop}px`;

        const scrollPercentage = newTop / (trackRect.height - this.Scrollbar.offsetHeight);
        this.CurrentPage = Math.round(scrollPercentage * (this.TotalPages - 1)) + 1;

        this.loadPageData();
    }
}

// Inicialização da classe ScrollBar
document.addEventListener('DOMContentLoaded', () => {
    const gridElement = document.getElementById('my-grid');
    const totalPages = 50;

    new ScrollBar(gridElement, totalPages, 10);
});
</script>

    </body>
</html>
